
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import java.io
import java.lang
import java.util
import java.util.regex
import jpype
import jpype.protocol
import typing



class GenericResourceManager: ...

class Language(java.lang.Enum['Language']):
    ENGLISH: typing.ClassVar['Language'] = ...
    GERMAN: typing.ClassVar['Language'] = ...
    DUTCH: typing.ClassVar['Language'] = ...
    ENGLISHCOLL: typing.ClassVar['Language'] = ...
    ENGLISHSCI: typing.ClassVar['Language'] = ...
    ITALIAN: typing.ClassVar['Language'] = ...
    SPANISH: typing.ClassVar['Language'] = ...
    VIETNAMESE: typing.ClassVar['Language'] = ...
    ARABIC: typing.ClassVar['Language'] = ...
    FRENCH: typing.ClassVar['Language'] = ...
    CHINESE: typing.ClassVar['Language'] = ...
    RUSSIAN: typing.ClassVar['Language'] = ...
    CROATIAN: typing.ClassVar['Language'] = ...
    PORTUGUESE: typing.ClassVar['Language'] = ...
    ESTONIAN: typing.ClassVar['Language'] = ...
    WILDCARD: typing.ClassVar['Language'] = ...
    @staticmethod
    def getLanguageFromString(string: str) -> 'Language': ...
    def getName(self) -> str: ...
    def getResourceFolder(self) -> str: ...
    def getTreeTaggerLangName(self) -> str: ...
    def getTreeTaggerSwitch(self) -> str: ...
    def toString(self) -> str: ...
    _valueOf_1__T = typing.TypeVar('_valueOf_1__T', bound=java.lang.Enum)  # <T>
    @typing.overload
    @staticmethod
    def valueOf(string: str) -> 'Language': ...
    @typing.overload
    @staticmethod
    def valueOf(class_: typing.Type[_valueOf_1__T], string: str) -> _valueOf_1__T: ...
    @staticmethod
    def values() -> typing.MutableSequence['Language']: ...

_RegexHashMap__T = typing.TypeVar('_RegexHashMap__T')  # <T>
class RegexHashMap(java.util.Map[str, _RegexHashMap__T], typing.Generic[_RegexHashMap__T]):
    def __init__(self): ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[str, _RegexHashMap__T]]: ...
    def get(self, object: typing.Any) -> _RegexHashMap__T: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[str]: ...
    def put(self, string: str, t: _RegexHashMap__T) -> _RegexHashMap__T: ...
    def putAll(self, map: typing.Union[java.util.Map[str, _RegexHashMap__T], typing.Mapping[str, _RegexHashMap__T]]) -> None: ...
    def putCache(self, string: str, t: _RegexHashMap__T) -> _RegexHashMap__T: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _RegexHashMap__T: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[_RegexHashMap__T]: ...

class ResourceMap(java.util.Map[str, str]):
    def __init__(self): ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[str, str]]: ...
    def get(self, object: typing.Any) -> str: ...
    def getInputStream(self, string: str) -> java.io.InputStream: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[str]: ...
    def put(self, string: str, string2: str) -> str: ...
    def putAll(self, map: typing.Union[java.util.Map[str, str], typing.Mapping[str, str]]) -> None: ...
    def putInnerFile(self, string: str, string2: str) -> str: ...
    def putOuterFile(self, string: str, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]) -> java.io.File: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> str: ...
    def size(self) -> int: ...
    def values(self) -> java.util.Collection[str]: ...

class ResourceScanner:
    def getDetectedResourceFolders(self) -> java.util.Set[str]: ...
    @staticmethod
    def getInstance() -> 'ResourceScanner': ...
    def getNormalizations(self, string: str) -> ResourceMap: ...
    def getRepatterns(self, string: str) -> ResourceMap: ...
    def getRules(self, string: str) -> ResourceMap: ...
    @staticmethod
    def main(stringArray: typing.Union[typing.List[str], jpype.JArray]) -> None: ...

class NormalizationManager(GenericResourceManager):
    def getFromHmAllNormalization(self, string: str) -> RegexHashMap[str]: ...
    def getFromNormDayInWeek(self, string: str) -> str: ...
    def getFromNormMonthInQuarter(self, string: str) -> str: ...
    def getFromNormMonthInSeason(self, string: str) -> str: ...
    def getFromNormMonthName(self, string: str) -> str: ...
    def getFromNormNumber(self, string: str) -> str: ...
    @staticmethod
    def getInstance(language: Language, boolean: bool) -> 'NormalizationManager': ...
    def readNormalizationResources(self, resourceMap: ResourceMap, boolean: bool) -> None: ...

class RePatternManager(GenericResourceManager):
    def containsKey(self, string: str) -> bool: ...
    def get(self, string: str) -> str: ...
    @staticmethod
    def getInstance(language: Language, boolean: bool) -> 'RePatternManager': ...

class RuleManager(GenericResourceManager):
    def getHmDateEmptyValue(self) -> java.util.HashMap[str, str]: ...
    def getHmDateFastCheck(self) -> java.util.HashMap[str, java.util.regex.Pattern]: ...
    def getHmDateFreq(self) -> java.util.HashMap[str, str]: ...
    def getHmDateMod(self) -> java.util.HashMap[str, str]: ...
    def getHmDateNormalization(self) -> java.util.HashMap[str, str]: ...
    def getHmDateOffset(self) -> java.util.HashMap[str, str]: ...
    def getHmDatePattern(self) -> java.util.HashMap[java.util.regex.Pattern, str]: ...
    def getHmDatePosConstraint(self) -> java.util.HashMap[str, str]: ...
    def getHmDateQuant(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationEmptyValue(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationFastCheck(self) -> java.util.HashMap[str, java.util.regex.Pattern]: ...
    def getHmDurationFreq(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationMod(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationNormalization(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationOffset(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationPattern(self) -> java.util.HashMap[java.util.regex.Pattern, str]: ...
    def getHmDurationPosConstraint(self) -> java.util.HashMap[str, str]: ...
    def getHmDurationQuant(self) -> java.util.HashMap[str, str]: ...
    def getHmSetEmptyValue(self) -> java.util.HashMap[str, str]: ...
    def getHmSetFastCheck(self) -> java.util.HashMap[str, java.util.regex.Pattern]: ...
    def getHmSetFreq(self) -> java.util.HashMap[str, str]: ...
    def getHmSetMod(self) -> java.util.HashMap[str, str]: ...
    def getHmSetNormalization(self) -> java.util.HashMap[str, str]: ...
    def getHmSetOffset(self) -> java.util.HashMap[str, str]: ...
    def getHmSetPattern(self) -> java.util.HashMap[java.util.regex.Pattern, str]: ...
    def getHmSetPosConstraint(self) -> java.util.HashMap[str, str]: ...
    def getHmSetQuant(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymEmptyValue(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymFastCheck(self) -> java.util.HashMap[str, java.util.regex.Pattern]: ...
    def getHmTemponymFreq(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymMod(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymNormalization(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymOffset(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymPattern(self) -> java.util.HashMap[java.util.regex.Pattern, str]: ...
    def getHmTemponymPosConstraint(self) -> java.util.HashMap[str, str]: ...
    def getHmTemponymQuant(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeEmptyValue(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeFastCheck(self) -> java.util.HashMap[str, java.util.regex.Pattern]: ...
    def getHmTimeFreq(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeMod(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeNormalization(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeOffset(self) -> java.util.HashMap[str, str]: ...
    def getHmTimePattern(self) -> java.util.HashMap[java.util.regex.Pattern, str]: ...
    def getHmTimePosConstraint(self) -> java.util.HashMap[str, str]: ...
    def getHmTimeQuant(self) -> java.util.HashMap[str, str]: ...
    @staticmethod
    def getInstance(language: Language, boolean: bool) -> 'RuleManager': ...
    def readRules(self, resourceMap: ResourceMap, string: str, boolean: bool) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("de.unihd.dbs.uima.annotator.heideltime.resources")``.

    GenericResourceManager: typing.Type[GenericResourceManager]
    Language: typing.Type[Language]
    NormalizationManager: typing.Type[NormalizationManager]
    RePatternManager: typing.Type[RePatternManager]
    RegexHashMap: typing.Type[RegexHashMap]
    ResourceMap: typing.Type[ResourceMap]
    ResourceScanner: typing.Type[ResourceScanner]
    RuleManager: typing.Type[RuleManager]
